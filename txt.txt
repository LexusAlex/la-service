Защита

https://www.digitalocean.com/community/tutorials/how-to-harden-openssh-on-ubuntu-18-04-ru

Сервис для собственных нужд

1. По максимуму автоматизируем

Деплой
https://blog.maxgraph.ru/deploj-sajta-s-github-na-khosting-cherez-ssh/
https://www.youtube.com/watch?v=_8sN0AaEVyE&t=100s

github actions

На самом github его можно перезапустить прямо в интерфейсе
https://antonshell.me/post/github-actions-symfony

ci/cd
https://github.com/LexusAlex/ci-cd-test

2. Минимум хлама в проекте
3. Не доверяем не одному узлу системы
4. Всегда все проверяем
5. Обновялем только по делу

Пример github action для прогона тестов

https://github.com/slimphp/Slim/blob/4.x/.github/workflows/tests.yml


## Структура проекта

1. backend- бэкенд на php
2. frontend -  фреймворке React или другом, но сначала изучить досконально react
https://deworker.pro/edu/series/what-is-react/javascript-render

Для dev разработки docker
docker compose run --rm backend-php-cli composer

-----
!!!
Что быстрее unix сокет или tcp сокет
https://zalinux.ru/?p=6293

Примечание: Аргумент fastcgi_pass должен быть определен как TCP-сокет или сокет Unix выбранным FastCGI сервером в его конфигурационном файле. По умолчанию для php-fpm используется сокет

fastcgi_pass unix:/run/php-fpm/php-fpm.sock;

Вы можете использовать также общий TCP-сокет:

fastcgi_pass 127.0.0.1:9000;

Однако, доменные сокеты Unix должны работать быстрее.
!!!
----


Выбор di контейнера
https://packagist.org/packages/league/container - здесь вообще нет ничего лишнего
https://github.com/yiisoft/di - здесь нет зависимостей
https://github.com/PHP-DI/PHP-DI
https://github.com/laminas/laminas-di - здесь тоже ничего нет


https://container.thephpleague.com/4.x/definitions/

Фреймворк
Почти идеал
https://packagist.org/packages/slim/slim


Версии ПО

php https://github.com/php/php-src/tags
composer https://github.com/composer/composer/tags
nginx https://github.com/nginx/nginx/tags
docker https://github.com/docker/cli/tags
docker-compose https://github.com/docker/compose/tags
mysql https://github.com/mysql/mysql-server/tags
ansible https://github.com/ansible/ansible/tags

Версии библиотек

php -v && nginx -v && composer -V


Docker

docker ps -q -f status=exited | xargs --no-run-if-empty docker rm

docker images - список образов

У phpstorm прекрасный интерфейс для работы с docker
docker compose run --rm backend-php-cli composer require yiisoft/di --prefer-dist

Composer

docker compose run --rm backend-php-cli composer install --dry-run - что будет происходить
docker compose run --rm backend-php-cli composer install --no-dev - не устанавливать пакеты
docker compose run --rm backend-php-cli composer install --optimize-autoloader быстрая автозагрузка классов
composer install --working-dir= --no-dev --optimize-autoloader --classmap-authoritative - как запускать на проде

docker compose run --rm backend-php-cli composer require monolog/monolog --dry-run - проверка что будет установлено
docker compose run --rm backend-php-cli composer remove monolog/monolog -удалить пакет

docker compose run --rm backend-php-cli composer check-platform-reqs - проверка php и расширений
docker compose run --rm backend-php-cli composer search monolog/monolog - поиск пакетов

docker compose run --rm backend-php-cli composer show -список всех установленных пакетов
docker compose run --rm backend-php-cli composer show -p - список платформ
docker compose run --rm backend-php-cli composer show -s - список корневых пакетов
docker compose run --rm backend-php-cli composer show -N - список имен пакетов
docker compose run --rm backend-php-cli composer show -l актуальные версии пакетов
docker compose run --rm backend-php-cli composer show -t дерево

docker compose run --rm backend-php-cli composer suggests - предлагаемые к установке пакеты
docker compose run --rm backend-php-cli composer outdated --direct - что можно обновить
docker compose run --rm backend-php-cli composer fund у кого указана информация для поддержки
docker compose run --rm backend-php-cli composer depends laminas/laminas-config-aggregator -r -t от чего зависит пакет

docker compose run --rm backend-php-cli composer validate - валидация схемы


Всегда запускаем
docker compose run --rm backend-php-cli composer validate
docker compose run --rm backend-php-cli composer status -v
docker compose run --rm backend-php-cli composer -t -r depends league/container
docker compose run --rm backend-php-cli composer show
docker compose run --rm backend-php-cli composer show -t

На боевом сервере всегда делать
composer install --no-dev --optimize-autoloader --classmap-authoritative
docker compose run --rm backend-php-cli composer outdated --direct

docker compose run --rm backend-php-cli composer require --dev vimeo/psalm
docker compose run --rm backend-php-cli composer require --dev psalm/plugin-phpunit
docker compose run --rm backend-php-cli composer require --dev lctrs/psalm-psr-container-plugin
webmozart/path-util is abandoned пакет будет удален https://github.com/vimeo/psalm/issues/6883

docker compose run --rm backend-php-cli composer require laminas/laminas-config-aggregator
docker compose run --rm backend-php-cli composer update roave/security-advisories

перевод
https://github.com/php-ru/composer-doc-ru
https://composer.json.jolicode.com/

https://php.watch/


Примерная структура api

Конфигурация каждого компонента складывается из трех окружений
development
production
test

1. Приложение хранит конфигурацию в переменных окружения.
2. Переменные окружения меняются между развертываниями.
3. Это дает гибкость и независимость.

Все приложение состоит из компонентов

Компонент может быть
доменный - Application это сама логика приложения
инфраструктурный API Gateway - здесь различные входы в приложение
вспомогательный - Component это настроки дополнителных компонентов

Структура - где каждый компонент отвечает за свою функциональность

API Gateway/ Входы в приложение
  /Http
    /Action Общие экшены
  /Console
Component/ Вспомогательные компоненты
  /Configuration Конфигурация всего приложения в целом
  /Slim Конфигурация фреймворка slim
    /Response Ответы экшена, завязан на Slim\Psr7
Application/ Компоненты приложения


Для контроля структуры можно установить https://qossmic.github.io/deptrac/#getting-started

ansible vars

role
  deploy
    repo
    path_project
    user
  nginx-host-backend
    path
    php_version
    config
    APPLICATION_ENVIRONMENT
    APPLICATION_DEBUG
  php
    php_version
  project
    dir
    user
    repo
  user
    user_name
    user_password


phpunit

Покрытие кода тестами
https://antonshell.me/post/php-code-coverage
Конфигурации библиотек добавить в отдельную директорию

docker compose run --rm backend-php-cli composer require --dev phpunit/phpunit

https://github.com/marketplace/actions/phpunit-php-actions?ysclid=l7p6hw1ybz942470325

https://antonshell.me/post/github-actions-symfony?ysclid=l7qkogkddf789528695


Доделать:
1.
Тестирование файла переменной окружения

public function testEnvironmentFile()
    {
        putenv("TEST_FILE=backend/123");
        //print_r(passthru('pwd'));
        var_dump(environment('TEST_FILE'));
    }
2.


Установка
phplint
----

docker compose run --rm backend-php-cli composer require overtrue/phplint --dev


php-cs-fixer

docker compose run --rm backend-php-cli composer require friendsofphp/php-cs-fixer --dev

psalm

Прибил гвоздями ошибку, пока не знаю как делать правильно
<errorLevel type="suppress">
        <file name="../src/Component/Slim/Response/JsonResponse.php" />
    </errorLevel>
</PropertyNotSetInConstructor>

Middleware

Bootstap по БЭМ
https://guides.hexlet.io/ru/bootstrap/?ysclid=l7xcr0zd5v673629012

PSR

PSR-7: HTTP Messages Общие интерфейсы запроса и ответа
MessageInterface
  RequestInterface - запрос
    ServerRequestInterface - серверный запрос
  ResponseInterface - ответ
StreamInterface - тело сообщения
UploadedFileInterface - загруженные файлы
UriInterface - url адрес
PSR-15: HTTP Server Request Handlers
  MiddlewareInterface - сам посредник между запросом и ответом c методом куда передается handler process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface;
  RequestHandlerInterface - фреймворко независимый контроллер должен быть с методом handle handle(ServerRequestInterface $request): ResponseInterface; такой контроллер может быть в любом приложении
    Это просто действие
PSR-17: HTTP Factories Интерфейсы к фабрикам для запросов и ответов идут поверх psr7
PSR-18: HTTP Client клиент

PSR-1 PSR-12 Code style
PSR-3: Logger Interface Логирование
PSR-4: Autoloader Стандарт загрузки файлов

PSR-6: Caching Interface система кеширования
PSR-16: Common Interface for Caching Libraries

PSR-11: Container interface Контейнер

PSR-14: Event Dispatcher Диспетчер событий


---
Работа slim framework
Начальная инициализация
-------
1. AppFactory::createFromContainer($container) -
Автоматическое Определение фабрики из следующих вариантов:
  SlimPsr17Factory::class,
  HttpSoftPsr17Factory::class,
  NyholmPsr17Factory::class,
  LaminasDiactorosPsr17Factory::class,
  GuzzlePsr17Factory::class,

  В нашем случае это пакет slim psr 7
  $responseFactory = Slim\Psr7\Factory\ResponseFactory
  Если ничего не найдено из этого списка будет ошибка
      Could not detect any PSR-17 ResponseFactory implementations. " .
      "Please install a supported implementation in order to use `AppFactory::create()`. " .
      "See https://github.com/slimphp/Slim/blob/4.x/README.md for a list of supported implementations.
2. Проверка на свой callableResolver,routeCollector,routeResolver,middlewareDispatcher
  В данном случае у нас их нет
3. Создаем приложение с параметрами в этих переменных
    $responseFactory, = Slim\Psr7\Factory\ResponseFactory PSR-17 совместимая фабрика серверного http-запроса
    $container = наш контейнер,  	Контейнер зависимостей
    $callableResolver, Обработчик вызываемых методов
    $routeCollector,    Роутер
    $routeResolver,     Обработчик результатов роутинга
    $middlewareDispatcher Промежуточное ПО

4. Там идет вызов родительского конструкутора RouteCollectorProxy
$responseFactory,
$callableResolver ?? new CallableResolver($container),
$container,
$routeCollector

Где создается CallableResolver с нашим контейнером на борту
Далее нужно создать new RouteCollector($responseFactory, $callableResolver, $container); это роутер
Куда передаются известные на данный момент обьекты|

Внутри
$this->responseFactory = $responseFactory;
$this->callableResolver = $callableResolver;
$this->container = $container;
$this->defaultInvocationStrategy = $defaultInvocationStrategy ?? new RequestResponse(); там есть код для вызова как функцю, но в данном случае этопросто пустой обьект
$this->routeParser = $routeParser ?? new RouteParser($this);

RouteParser - здесь создаем новый парсер и так же создаем обьект другой библиотеки FastRoute\RouteParser\Std это то что использует слим для работы

В итоге на руках у нас следующие переменные
$responseFactory,
$callableResolver
$container,
$routeCollector

Теперь создаем new RouteResolver($this->routeCollector); Там внутри в конструктуре создается new Dispatcher($routeCollector);
Далее new RouteRunner($this->routeResolver, $this->routeCollector->getRouteParser(), $this); Пока это все подготовитетельные обьекты

Время для - middleware $middlewareDispatcher = new MiddlewareDispatcher($routeRunner, $this->callableResolver, $container); PSR-15
устанавливаем тип и как всегда присваемваем переменным
теперь на руках еще и $this->middlewareDispatcher = $middlewareDispatcher;

Сейчас у нас сделана вся подготовительная работа
----------
Добавление middleware
Это такие посредники код которых выполнятся до выполнения action.
Можно сказать это такая воронка через которую пропускается запрос
Для обработки ошибок
addErrorMiddleware(false,false,false)

Здесь создаем middleware

$errorMiddleware =
new ErrorMiddleware(
$this->getCallableResolver(), разрешитель имен
$this->getResponseFactory(), psr7 запрос ответ
$displayErrorDetails, показывать ли детальное отображение ошибок
$logErrors, вести ли ошибки в лог
$logErrorDetails, вести ли в лог детальное отображение ошибок
$logger обьект логгера
);

Вызов middleware идет наоборот снизу вверх, нужно это учитывать
Вызов action
$application->add(\LaService\ApiGateway\Http\Middleware\Test::class);
$application->add(\LaService\ApiGateway\Http\Middleware\Test2::class);

Как работает ErrorMiddleware
1. Вызываться метод process
2. Если все ок, запрос корректен, то работа передается следующему middleware
3. Если не ок, то вызывается handleException, там опредлеяется ErrorHandler
4. Далее вызывается $handler($request, $exception, $this->displayErrorDetails, $this->logErrors, $this->logErrorDetails); как функция передавая туда все данные
5. В обьекте ErrorHandler вызывется __invoke
6. Пишем сообщение в лог
7. Вызывается метод respond
8. Формируется новый response и рендерится в браузер
---------
Добавление роутов

1. Создание машрута $this->createRoute($methods, $pattern, $handler);
2. Добавление роута в массив $this->routes и назначение ему идентификатора, в данном случае это route0
3. Всего маршрутов в системе routeCounter, хотя бы один маршрут должен быть иначе будет ошибка 404
4. Маршрут добавлен
--------
Запуск приложения

$application->run();
1. Получаем текущий запрос
2. Получаем ответ $this->handle($request) Там внутри определяем текущий роутер; но преждe вызываем все middleware
3. создаем $responseEmitter = new ResponseEmitter();
4. $responseEmitter->emit($response);
5. Проверка на пустоту $this->isResponseEmpty($response)
6. Происходит ответ в браузер $this->emitStatusLine($response);

----------

Проверяем почему не можем обновиться до следующей версии пакета
docker compose run --rm backend-php-cli composer update phpunit/phpunit:9.5.25

Problem 1
    - Root composer.json requires phpunit/phpunit ^9.5 -> satisfiable by phpunit/phpunit[9.5.25].
    - phpunit/phpunit 9.5.25 requires sebastian/comparator ^4.0.8 -> found sebastian/comparator[4.0.8] but the package is fixed to 4.0.6 (lock file version) by a partial update and that version does not match. Make sure you list it as an argument for the update command.


Продумать нужно ли ставить sentry

Расмотреть

infection
deptrac

Логирование